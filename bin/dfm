#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use FindBin qw($Bin);
use Getopt::Long;

my $command;
foreach my $arg (@ARGV) {
    next if $arg =~ /^-/;
    $command = $arg;
}

if ( !$command ) {
    $command = 'install';
}

my $repo_dir = $Bin;
$repo_dir =~ s/$ENV{HOME}\///;
$repo_dir =~ s/\/bin//;

DEBUG("Repo dir: $repo_dir");

my %opts;
if ( $command eq 'install' ) {
    GetOptions( \%opts, 'verbose', 'quiet', 'dry-run', 'help' );

    if ($opts{'help'}) {
        show_usage();
        exit;
    }

    INFO(
        "Installing dotfiles..." . ( $opts{'dry-run'} ? ' (dry run)' : '' ) );

    DEBUG("Running in [$Bin] and installing in [$ENV{HOME}]");

    # isntall main files
    install_files( $ENV{HOME} . '/' . $repo_dir,
        $ENV{HOME}, [qw(.git .gitignore .ssh README.md)] );

    # install files in the .ssh directory
    install_files(
        $ENV{HOME} . '/' . $repo_dir . '/.ssh',
        $ENV{HOME} . '/.ssh',
        ['.gitignore']
    );

    # link in the bash loader
    configure_bash_loader();
}
else {

    # assume it's a git command and call accordingly
    chdir( $ENV{HOME} . '/' . $repo_dir );
    exec( 'git', @ARGV );
    exit;
}

exit;

# a couple of log4perl-alikes
sub INFO {
    printf "INFO: %s\n", shift if !$opts{quiet};
}

sub DEBUG {
    printf "DEBUG: %s\n", shift if $opts{verbose};
}

# function to install files
sub install_files {
    my ( $from_dir, $to_dir, $initial_skips ) = @_;
    $initial_skips ||= [];

    my $backup_dir = $to_dir . '/.backup';
    DEBUG("Backup dir: $backup_dir");

    chdir($to_dir);

    # build up skip list
    my $skip_files = { map { $_ => 1 } @$initial_skips };
    if ( -e "$from_dir/skip" ) {
        open( my $skip_fh, '<', "$from_dir/skip" );
        foreach my $line (<$skip_fh>) {
            chomp($line);
            $skip_files->{$line} = 1;
        }
        close($skip_fh);
        $skip_files->{skip} = 1;

        DEBUG("Skipped file: $_") for keys %$skip_files;
    }

    if ( !-e $backup_dir ) {
        DEBUG("Creating $backup_dir");
        mkdir($backup_dir) if !$opts{'dry-run'};
    }

    my $dirh;
    opendir $dirh, $from_dir;
    foreach my $direntry ( readdir($dirh) ) {

        # skip current and parent
        next if $direntry eq '.' or $direntry eq '..';

        # skip any other files
        next if $skip_files->{$direntry};

        DEBUG(" Working on $direntry");

        if ( !-l $direntry ) {
            if ( -e $direntry ) {
                INFO("  Backing up $direntry.");
                system("mv $direntry $backup_dir/$direntry")
                    if !$opts{'dry-run'};
            }
            INFO("  Symlinking $direntry.");
            symlink( "$from_dir/$direntry", "$direntry" )
                if !$opts{'dry-run'};
        }
    }
}

sub configure_bash_loader {
    chdir( $ENV{HOME} );

    my $bashrc_contents;
    {
        local $/ = undef;
        if ( open( my $bashrc_in, '<', ".bashrc" ) ) {
            $bashrc_contents = <$bashrc_in>;
            close $bashrc_in;
        }
        else {
            $bashrc_contents = '';
        }
    }

    # check if the loader is in
    if ( $bashrc_contents !~ /\.bashrc\.load/ ) {
        INFO("Appending loader to .bashrc");
        $bashrc_contents .= "\n. \$HOME/.bashrc.load\n";
    }

    if ( !$opts{'dry-run'} ) {
        open( my $bashrc_out, '>', ".bashrc" );
        print $bashrc_out $bashrc_contents;
        close $bashrc_out;
    }
}

sub show_usage {
    print <<END;
Usage:
    dfm install [--verbose|--quiet] [--dry-run]
    dfm [git subcommand] [git options]

For full documentation, run "perldoc ~/$repo_dir/bin/dfm".
END
}

__END__

=head1 NAME

    dfm - A script to manage a dotfiles repository

=head1 SYNOPSIS

    dfm install [--verbose|--quiet] [--dry-run]

    dfm [git subcommand] [git options]

=head1 DESCRIPTION

    Manages installing files from and operating on a repository that contains
    dotfiles.

=head1 COMMANDS

=over

=item dfm install

This installs everything in the repository into the current user's home
directory by making symlinks.  To skip any files, add their names to a file
named 'skip' in the base of the repository.  This is the default command.

=item dfm [git subcommand]

This runs any git command as if it was inside the dotfiles repository.  For
instance, this makes it easy to commit changes that are made by running 'dfm
commit'.

=back

=head1 AUTHOR

Nate Jones <nate@endot.org>

=head1 COPYRIGHT

Copyright (c) 2010 L</AUTHOR> as listed above.

=head1 LICENSE

This program is free software distributed under the Artistic License 2.0.

=cut
